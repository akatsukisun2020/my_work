In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h: In instantiation of ‘struct std::__detail::_Hash_code_base<std::vector<int>, std::pair<const std::vector<int>, Cell>, std::__detail::_Select1st, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>’:
/usr/include/c++/4.8/bits/hashtable_policy.h:1402:10:   required from ‘struct std::__detail::_Hashtable_base<std::vector<int>, std::pair<const std::vector<int>, Cell>, std::__detail::_Select1st, std::equal_to<std::vector<int> >, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >’
/usr/include/c++/4.8/bits/hashtable.h:174:11:   required from ‘class std::_Hashtable<std::vector<int>, std::pair<const std::vector<int>, Cell>, std::allocator<std::pair<const std::vector<int>, Cell> >, std::__detail::_Select1st, std::equal_to<std::vector<int> >, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >’
/usr/include/c++/4.8/bits/unordered_map.h:100:18:   required from ‘class std::unordered_map<std::vector<int>, Cell>’
grid.h:66:38:   required from here
/usr/include/c++/4.8/bits/hashtable_policy.h:1070:12: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1070:12: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1082:53: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1082:53: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h: In instantiation of ‘struct std::__detail::_Hash_code_base<std::vector<int>, std::vector<int>, std::__detail::_Identity, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>’:
/usr/include/c++/4.8/bits/hashtable_policy.h:1402:10:   required from ‘struct std::__detail::_Hashtable_base<std::vector<int>, std::vector<int>, std::__detail::_Identity, std::equal_to<std::vector<int> >, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, true, true> >’
/usr/include/c++/4.8/bits/hashtable.h:174:11:   required from ‘class std::_Hashtable<std::vector<int>, std::vector<int>, std::allocator<std::vector<int> >, std::__detail::_Identity, std::equal_to<std::vector<int> >, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, true, true> >’
/usr/include/c++/4.8/bits/unordered_set.h:96:18:   required from ‘class std::unordered_set<std::vector<int> >’
cluster.h:30:32:   required from here
/usr/include/c++/4.8/bits/hashtable_policy.h:1070:12: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1070:12: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1082:53: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1082:53: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from test_main.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
test_main.cc: In function ‘int main()’:
test_main.cc:19:60: error: conversion from ‘std::unordered_map<std::vector<int>, Cell>’ to non-scalar type ‘std::map<std::vector<int>, Cell>’ requested
     map<vector<int>, Cell> grid_info1 = grid1.get_gridinfo();
                                                            ^
test_main.cc:20:60: error: conversion from ‘std::unordered_map<std::vector<int>, Cell>’ to non-scalar type ‘std::map<std::vector<int>, Cell>’ requested
     map<vector<int>, Cell> grid_info2 = grid2.get_gridinfo();
                                                            ^
test_main.cc:21:60: error: conversion from ‘std::unordered_map<std::vector<int>, Cell>’ to non-scalar type ‘std::map<std::vector<int>, Cell>’ requested
     map<vector<int>, Cell> grid_info3 = grid3.get_gridinfo();
                                                            ^
test_main.cc:24:35: error: no matching function for call to ‘CLUSTER::merge_grids(std::map<std::vector<int>, Cell>&)’
     cluster.merge_grids(grid_info1);
                                   ^
test_main.cc:24:35: note: candidate is:
In file included from test_main.cc:1:0:
cluster.h:17:10: note: void CLUSTER::merge_grids(std::unordered_map<std::vector<int>, Cell>&)
     void merge_grids(unordered_map<vector<int>, Cell>& grid);
          ^
cluster.h:17:10: note:   no known conversion for argument 1 from ‘std::map<std::vector<int>, Cell>’ to ‘std::unordered_map<std::vector<int>, Cell>&’
test_main.cc:25:35: error: no matching function for call to ‘CLUSTER::merge_grids(std::map<std::vector<int>, Cell>&)’
     cluster.merge_grids(grid_info2);
                                   ^
test_main.cc:25:35: note: candidate is:
In file included from test_main.cc:1:0:
cluster.h:17:10: note: void CLUSTER::merge_grids(std::unordered_map<std::vector<int>, Cell>&)
     void merge_grids(unordered_map<vector<int>, Cell>& grid);
          ^
cluster.h:17:10: note:   no known conversion for argument 1 from ‘std::map<std::vector<int>, Cell>’ to ‘std::unordered_map<std::vector<int>, Cell>&’
test_main.cc:26:35: error: no matching function for call to ‘CLUSTER::merge_grids(std::map<std::vector<int>, Cell>&)’
     cluster.merge_grids(grid_info3);
                                   ^
test_main.cc:26:35: note: candidate is:
In file included from test_main.cc:1:0:
cluster.h:17:10: note: void CLUSTER::merge_grids(std::unordered_map<std::vector<int>, Cell>&)
     void merge_grids(unordered_map<vector<int>, Cell>& grid);
          ^
cluster.h:17:10: note:   no known conversion for argument 1 from ‘std::map<std::vector<int>, Cell>’ to ‘std::unordered_map<std::vector<int>, Cell>&’
test_main.cc:34:60: error: conversion from ‘std::unordered_map<std::vector<int>, Cell>’ to non-scalar type ‘std::map<std::vector<int>, Cell>’ requested
     map<vector<int>, Cell> grid_info1 = grid1.get_gridinfo();
                                                            ^
test_main.cc:35:60: error: conversion from ‘std::unordered_map<std::vector<int>, Cell>’ to non-scalar type ‘std::map<std::vector<int>, Cell>’ requested
     map<vector<int>, Cell> grid_info2 = grid2.get_gridinfo();
                                                            ^
test_main.cc:36:60: error: conversion from ‘std::unordered_map<std::vector<int>, Cell>’ to non-scalar type ‘std::map<std::vector<int>, Cell>’ requested
     map<vector<int>, Cell> grid_info3 = grid3.get_gridinfo();
                                                            ^
test_main.cc:39:35: error: no matching function for call to ‘CLUSTER::merge_grids(std::map<std::vector<int>, Cell>&)’
     cluster.merge_grids(grid_info1);
                                   ^
test_main.cc:39:35: note: candidate is:
In file included from test_main.cc:1:0:
cluster.h:17:10: note: void CLUSTER::merge_grids(std::unordered_map<std::vector<int>, Cell>&)
     void merge_grids(unordered_map<vector<int>, Cell>& grid);
          ^
cluster.h:17:10: note:   no known conversion for argument 1 from ‘std::map<std::vector<int>, Cell>’ to ‘std::unordered_map<std::vector<int>, Cell>&’
test_main.cc:40:35: error: no matching function for call to ‘CLUSTER::merge_grids(std::map<std::vector<int>, Cell>&)’
     cluster.merge_grids(grid_info2);
                                   ^
test_main.cc:40:35: note: candidate is:
In file included from test_main.cc:1:0:
cluster.h:17:10: note: void CLUSTER::merge_grids(std::unordered_map<std::vector<int>, Cell>&)
     void merge_grids(unordered_map<vector<int>, Cell>& grid);
          ^
cluster.h:17:10: note:   no known conversion for argument 1 from ‘std::map<std::vector<int>, Cell>’ to ‘std::unordered_map<std::vector<int>, Cell>&’
test_main.cc:41:35: error: no matching function for call to ‘CLUSTER::merge_grids(std::map<std::vector<int>, Cell>&)’
     cluster.merge_grids(grid_info3);
                                   ^
test_main.cc:41:35: note: candidate is:
In file included from test_main.cc:1:0:
cluster.h:17:10: note: void CLUSTER::merge_grids(std::unordered_map<std::vector<int>, Cell>&)
     void merge_grids(unordered_map<vector<int>, Cell>& grid);
          ^
cluster.h:17:10: note:   no known conversion for argument 1 from ‘std::map<std::vector<int>, Cell>’ to ‘std::unordered_map<std::vector<int>, Cell>&’
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h: In instantiation of ‘struct std::__detail::_Hash_code_base<std::vector<int>, std::pair<const std::vector<int>, Cell>, std::__detail::_Select1st, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>’:
/usr/include/c++/4.8/bits/hashtable_policy.h:1402:10:   required from ‘struct std::__detail::_Hashtable_base<std::vector<int>, std::pair<const std::vector<int>, Cell>, std::__detail::_Select1st, std::equal_to<std::vector<int> >, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >’
/usr/include/c++/4.8/bits/hashtable.h:174:11:   required from ‘class std::_Hashtable<std::vector<int>, std::pair<const std::vector<int>, Cell>, std::allocator<std::pair<const std::vector<int>, Cell> >, std::__detail::_Select1st, std::equal_to<std::vector<int> >, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >’
/usr/include/c++/4.8/bits/unordered_map.h:100:18:   required from ‘class std::unordered_map<std::vector<int>, Cell>’
grid.h:66:38:   required from here
/usr/include/c++/4.8/bits/hashtable_policy.h:1070:12: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1070:12: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1082:53: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1082:53: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h: In instantiation of ‘struct std::__detail::_Hash_code_base<std::vector<int>, std::vector<int>, std::__detail::_Identity, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>’:
/usr/include/c++/4.8/bits/hashtable_policy.h:1402:10:   required from ‘struct std::__detail::_Hashtable_base<std::vector<int>, std::vector<int>, std::__detail::_Identity, std::equal_to<std::vector<int> >, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, true, true> >’
/usr/include/c++/4.8/bits/hashtable.h:174:11:   required from ‘class std::_Hashtable<std::vector<int>, std::vector<int>, std::allocator<std::vector<int> >, std::__detail::_Identity, std::equal_to<std::vector<int> >, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, true, true> >’
/usr/include/c++/4.8/bits/unordered_set.h:96:18:   required from ‘class std::unordered_set<std::vector<int> >’
cluster.h:30:32:   required from here
/usr/include/c++/4.8/bits/hashtable_policy.h:1070:12: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1070:12: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1082:53: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1082:53: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
cluster.cc: In constructor ‘std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::vector<int>; _Tp = Cell; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]’:
cluster.cc:3:18: error: invalid use of incomplete type ‘std::unordered_map<std::vector<int>, Cell>::hasher {aka struct std::hash<std::vector<int> >}’
 CLUSTER::CLUSTER(){
                  ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘std::unordered_map<std::vector<int>, Cell>::hasher {aka struct std::hash<std::vector<int> >}’
     struct hash;
            ^
cluster.cc:3:18: note:   when instantiating default argument for call to std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::vector<int>; _Tp = Cell; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]
 CLUSTER::CLUSTER(){
                  ^
cluster.cc: In constructor ‘std::unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(std::unordered_set<_Value, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Value = std::vector<int>; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::vector<int> >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::hasher = std::hash<std::vector<int> >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::vector<int> >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::vector<int> >]’:
cluster.cc:3:18: error: invalid use of incomplete type ‘std::unordered_set<std::vector<int> >::hasher {aka struct std::hash<std::vector<int> >}’
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘std::unordered_set<std::vector<int> >::hasher {aka struct std::hash<std::vector<int> >}’
     struct hash;
            ^
cluster.cc:3:18: note:   when instantiating default argument for call to std::unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(std::unordered_set<_Value, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Value = std::vector<int>; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::vector<int> >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::hasher = std::hash<std::vector<int> >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::vector<int> >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::vector<int> >]
 CLUSTER::CLUSTER(){
                  ^
cluster.cc: In member function ‘void CLUSTER::merge_grids(std::unordered_map<std::vector<int>, Cell>&)’:
cluster.cc:31:62: error: invalid initialization of reference of type ‘std::vector<int>&’ from expression of type ‘std::vector<Pulse>’
       merge_vector((iter->second).points, (it->second).points);
                                                              ^
cluster.cc:11:6: error: in passing argument 1 of ‘void merge_vector(std::vector<int>&, std::vector<int>&)’
 void merge_vector(vector<int>& array1, vector<int>& array2){
      ^
cluster.cc: In member function ‘void CLUSTER::bft_grid(Cell&, int)’:
cluster.cc:40:23: error: base operand of ‘->’ has non-pointer type ‘Cell’
     noise_.insert(cell->id); 
                       ^
cluster.cc:44:10: error: base operand of ‘->’ has non-pointer type ‘Cell’
   if(cell->cluid != 0) //说明已经被遍历过了的
          ^
cluster.cc:47:7: error: base operand of ‘->’ has non-pointer type ‘Cell’
   cell->cluid = cluster_id;
       ^
cluster.cc:54:23: error: base operand of ‘->’ has non-pointer type ‘Cell’
       index[j] = (cell->id)[j] + delta[i][j];
                       ^
cluster.cc: In member function ‘void CLUSTER::deal_noise_cell_1()’:
cluster.cc:93:25: error: base operand of ‘->’ has non-pointer type ‘Cell’
         index[j] = (cell->id)[j] + delta[i][j];
                         ^
cluster.cc: In member function ‘void CLUSTER::deal_noise_cell_2()’:
cluster.cc:144:25: error: base operand of ‘->’ has non-pointer type ‘Cell’
         index[j] = (cell->id)[j] + delta[i][j];
                         ^
cluster.cc:157:9: error: ‘cout’ was not declared in this scope
         cout<<"error: belong to deal_noise_1"<<endl;
         ^
cluster.cc:157:48: error: ‘endl’ was not declared in this scope
         cout<<"error: belong to deal_noise_1"<<endl;
                                                ^
cluster.cc:157:48: note: suggested alternative:
In file included from /usr/include/c++/4.8/istream:39:0,
                 from /usr/include/c++/4.8/fstream:38,
                 from grid.h:8,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/ostream:564:5: note:   ‘std::endl’
     endl(basic_ostream<_CharT, _Traits>& __os)
     ^
cluster.cc:161:12: error: no match for ‘operator=’ (operand types are ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ and ‘std::unordered_map<int, int>::iterator {aka std::__detail::_Node_iterator<std::pair<const int, int>, false, false>}’)
       iter = cluid_count.find(key_cluid);
            ^
cluster.cc:161:12: note: candidates are:
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:231:12: note: std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>& std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>::operator=(const std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>&)
     struct _Node_iterator
            ^
/usr/include/c++/4.8/bits/hashtable_policy.h:231:12: note:   no known conversion for argument 1 from ‘std::unordered_map<int, int>::iterator {aka std::__detail::_Node_iterator<std::pair<const int, int>, false, false>}’ to ‘const std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>&’
/usr/include/c++/4.8/bits/hashtable_policy.h:231:12: note: std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>& std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>::operator=(std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>&&)
/usr/include/c++/4.8/bits/hashtable_policy.h:231:12: note:   no known conversion for argument 1 from ‘std::unordered_map<int, int>::iterator {aka std::__detail::_Node_iterator<std::pair<const int, int>, false, false>}’ to ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>&&’
cluster.cc:162:15: error: no match for ‘operator==’ (operand types are ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ and ‘std::unordered_map<int, int>::iterator {aka std::__detail::_Node_iterator<std::pair<const int, int>, false, false>}’)
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
               ^
cluster.cc:162:15: note: candidates are:
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1260:5: note: template<class _Key, class _Value, class _ExtractKey, class _H1, class _H2, class _Hash, bool __cache> bool std::__detail::operator==(const std::__detail::_Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>&, const std::__detail::_Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>&)
     operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,
     ^
/usr/include/c++/4.8/bits/hashtable_policy.h:1260:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::__detail::_Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:219:5: note: template<class _Value, bool _Cache_hash_code> bool std::__detail::operator==(const std::__detail::_Node_iterator_base<_Value, _Cache_hash_code>&, const std::__detail::_Node_iterator_base<_Value, _Cache_hash_code>&)
     operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
     ^
/usr/include/c++/4.8/bits/hashtable_policy.h:219:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   deduced conflicting types for parameter ‘_Value’ (‘std::pair<const std::vector<int>, Cell>’ and ‘std::pair<const int, int>’)
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/unordered_set:48:0,
                 from cluster.h:6,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/unordered_set.h:1283:5: note: template<class _Value, class _Hash, class _Pred, class _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)
     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_set.h:1283:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/unordered_set:48:0,
                 from cluster.h:6,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/unordered_set.h:1271:5: note: template<class _Value, class _Hash, class _Pred, class _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)
     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_set.h:1271:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::unordered_set<_Value, _Hash, _Pred, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/unordered_map.h:1400:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1400:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/unordered_map.h:1388:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1388:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/istream:38,
                 from /usr/include/c++/4.8/fstream:38,
                 from grid.h:8,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:204:5: note: template<class _CharT, class _Traits> bool std::operator==(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:204:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/queue:64:0,
                 from grid.h:6,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_queue.h:268:5: note: template<class _Tp, class _Seq> bool std::operator==(const std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)
     operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
     ^
/usr/include/c++/4.8/bits/stl_queue.h:268:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::queue<_Tp, _Seq>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/deque:64:0,
                 from /usr/include/c++/4.8/queue:60,
                 from grid.h:6,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_deque.h:1957:5: note: template<class _Tp, class _Alloc> bool std::operator==(const std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)
     operator==(const deque<_Tp, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/stl_deque.h:1957:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::deque<_Tp, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/deque:64:0,
                 from /usr/include/c++/4.8/queue:60,
                 from grid.h:6,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_deque.h:254:5: note: template<class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)
     operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_deque.h:254:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::_Deque_iterator<_Tp, _Ref, _Ptr>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/deque:64:0,
                 from /usr/include/c++/4.8/queue:60,
                 from grid.h:6,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_deque.h:247:5: note: template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref, _Ptr>&)
     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
     ^
/usr/include/c++/4.8/bits/stl_deque.h:247:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::_Deque_iterator<_Tp, _Ref, _Ptr>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/map:62:0,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_multimap.h:864:5: note: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&, const std::multimap<_Key, _Tp, _Compare, _Alloc>&)
     operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/stl_multimap.h:864:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::multimap<_Key, _Tp, _Compare, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/map:61:0,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_map.h:962:5: note: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key, _Tp, _Compare, _Alloc>&)
     operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/stl_map.h:962:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::map<_Key, _Tp, _Compare, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/stl_map.h:63:0,
                 from /usr/include/c++/4.8/map:61,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/tuple:813:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator==(const std::tuple<_Args1 ...>&, const std::tuple<_Args2 ...>&)
     operator==(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:813:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::tuple<_Args1 ...>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/bits/stl_map.h:63,
                 from /usr/include/c++/4.8/map:61,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/array:228:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:228:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::array<_Tp, _Nm>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/bits/stl_map.h:63,
                 from /usr/include/c++/4.8/map:61,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/basic_string.h:2519:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2519:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/bits/stl_map.h:63,
                 from /usr/include/c++/4.8/map:61,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/basic_string.h:2507:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator==(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2507:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   mismatched types ‘const _CharT*’ and ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/bits/stl_map.h:63,
                 from /usr/include/c++/4.8/map:61,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/basic_string.h:2493:5: note: template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value, bool>::__type std::operator==(const std::basic_string<_CharT>&, const std::basic_string<_CharT>&)
     operator==(const basic_string<_CharT>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2493:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::basic_string<_CharT>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/bits/stl_map.h:63,
                 from /usr/include/c++/4.8/map:61,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/basic_string.h:2486:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2486:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/bits/stl_map.h:63,
                 from /usr/include/c++/4.8/map:61,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/postypes.h:216:5: note: template<class _StateT> bool std::operator==(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:216:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::fpos<_StateT>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/map:60:0,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_tree.h:907:5: note: template<class _Key, class _Val, class _KeyOfValue, class _Compare, class _Alloc> bool std::operator==(const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&, const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&)
     operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/stl_tree.h:907:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/map:60:0,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_tree.h:310:5: note: template<class _Val> bool std::operator==(const std::_Rb_tree_iterator<_Tp>&, const std::_Rb_tree_const_iterator<_Val>&)
     operator==(const _Rb_tree_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_tree.h:310:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::_Rb_tree_iterator<_Tp>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_vector.h:1404:5: note: template<class _Tp, class _Alloc> bool std::operator==(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1404:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::vector<_Tp, _Alloc>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/vector:61:0,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/allocator.h:133:5: note: template<class _Tp> bool std::operator==(const std::allocator<_Tp1>&, const std::allocator<_Tp1>&)
     operator==(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:133:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::allocator<_Tp1>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/vector:61:0,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/allocator.h:128:5: note: template<class _T1, class _T2> bool std::operator==(const std::allocator<_Tp1>&, const std::allocator<_T2>&)
     operator==(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:128:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::allocator<_Tp1>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/vector:60,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1037:5: note: template<class _Iterator> bool std::operator==(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator==(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1037:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::move_iterator<_Iterator>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/vector:60,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1031:5: note: template<class _IteratorL, class _IteratorR> bool std::operator==(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator==(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1031:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::move_iterator<_Iterator>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/vector:60,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_iterator.h:341:5: note: template<class _IteratorL, class _IteratorR> bool std::operator==(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator==(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:341:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::reverse_iterator<_Iterator>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/vector:60,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_iterator.h:291:5: note: template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator==(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:291:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::reverse_iterator<_Iterator>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:64:0,
                 from /usr/include/c++/4.8/vector:60,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_pair.h:214:5: note: template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:214:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const std::pair<_T1, _T2>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h:33:0,
                 from /usr/include/c++/4.8/bits/allocator.h:46,
                 from /usr/include/c++/4.8/vector:61,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/ext/new_allocator.h:139:5: note: template<class _Tp> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<_Tp>&, const __gnu_cxx::new_allocator<_Tp>&)
     operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
     ^
/usr/include/c++/4.8/ext/new_allocator.h:139:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const __gnu_cxx::new_allocator<_Tp>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/vector:60,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_iterator.h:811:5: note: template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator, _Container>&)
     operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:811:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const __gnu_cxx::__normal_iterator<_Iterator, _Container>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/vector:60,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/stl_iterator.h:805:5: note: template<class _IteratorL, class _IteratorR, class _Container> bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)
     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:805:5: note:   template argument deduction/substitution failed:
cluster.cc:162:34: note:   ‘std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>’ is not derived from ‘const __gnu_cxx::__normal_iterator<_IteratorL, _Container>’
       if(iter == cluid_count.end() && key_cluid != 0){ //这里要排除周围
                                  ^
cluster.cc: In member function ‘void CLUSTER::get_minPts()’:
cluster.cc:205:13: error: return-statement with a value, in function returning 'void' [-fpermissive]
     return -1;
             ^
cluster.cc: In member function ‘void CLUSTER::print_result()’:
cluster.cc:242:37: error: ‘to_string’ was not declared in this scope
     string id = to_string(cell.cluid);
                                     ^
cluster.cc:242:37: note: suggested alternative:
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/bits/stl_map.h:63,
                 from /usr/include/c++/4.8/map:61,
                 from grid.h:5,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/basic_string.h:2916:3: note:   ‘std::to_string’
   to_string(long double __val)
   ^
cluster.cc:243:32: error: invalid initialization of reference of type ‘std::vector<int>&’ from expression of type ‘std::vector<Pulse>’
     vector<int>& points = cell.points;
                                ^
cluster.cc:245:29: error: request for member ‘label’ in ‘(& points)->std::vector<_Tp, _Alloc>::operator[]<int, std::allocator<int> >(((std::vector<int>::size_type)i))’, which is of non-class type ‘__gnu_cxx::__alloc_traits<std::allocator<int> >::value_type {aka int}’
       int label = points[i].label;
                             ^
cluster.cc:287:3: error: ‘cout’ was not declared in this scope
   cout<<"total_number : "<<total_number<<endl;
   ^
cluster.cc:287:42: error: ‘endl’ was not declared in this scope
   cout<<"total_number : "<<total_number<<endl;
                                          ^
cluster.cc:287:42: note: suggested alternative:
In file included from /usr/include/c++/4.8/istream:39:0,
                 from /usr/include/c++/4.8/fstream:38,
                 from grid.h:8,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/ostream:564:5: note:   ‘std::endl’
     endl(basic_ostream<_CharT, _Traits>& __os)
     ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h: In instantiation of ‘std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, true>::__hash_code std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, true>::_M_hash_code(const _Key&) const [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _ExtractKey = std::__detail::_Select1st; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, true>::__hash_code = long unsigned int]’:
/usr/include/c++/4.8/bits/hashtable.h:1023:50:   required from ‘std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::iterator std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::find(const key_type&) [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; _ExtractKey = std::__detail::_Select1st; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _RehashPolicy = std::__detail::_Prime_rehash_policy; _Traits = std::__detail::_Hashtable_traits<true, false, true>; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::iterator = std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::key_type = std::vector<int>]’
/usr/include/c++/4.8/bits/unordered_map.h:543:29:   required from ‘std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::find(const key_type&) [with _Key = std::vector<int>; _Tp = Cell; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type = std::vector<int>]’
cluster.cc:25:37:   required from here
/usr/include/c++/4.8/bits/hashtable_policy.h:1103:22: error: no match for call to ‘(const std::hash<std::vector<int> >) (const std::vector<int>&)’
       { return _M_h1()(__k); }
                      ^
/usr/include/c++/4.8/bits/hashtable_policy.h: In instantiation of ‘std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, true>::_Hash_code_base(const _ExtractKey&, const _H1&, const _H2&, const std::__detail::_Default_ranged_hash&) [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _ExtractKey = std::__detail::_Select1st; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing]’:
/usr/include/c++/4.8/bits/hashtable_policy.h:1463:65:   required from ‘std::__detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>::_Hashtable_base(const _ExtractKey&, const _H1&, const _H2&, const _Hash&, const _Equal&) [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _ExtractKey = std::__detail::_Select1st; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _Traits = std::__detail::_Hashtable_traits<true, false, true>]’
/usr/include/c++/4.8/bits/hashtable.h:828:24:   required from ‘std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable(std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type, const _H1&, const _H2&, const _Hash&, const _Equal&, const _ExtractKey&, const allocator_type&) [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; _ExtractKey = std::__detail::_Select1st; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _RehashPolicy = std::__detail::_Prime_rehash_policy; _Traits = std::__detail::_Hashtable_traits<true, false, true>; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type = long unsigned int; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]’
/usr/include/c++/4.8/bits/hashtable.h:397:26:   required from ‘std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable(std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type, const _H1&, const key_equal&, const allocator_type&) [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; _ExtractKey = std::__detail::_Select1st; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _RehashPolicy = std::__detail::_Prime_rehash_policy; _Traits = std::__detail::_Hashtable_traits<true, false, true>; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type = long unsigned int; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::key_equal = std::equal_to<std::vector<int> >; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]’
/usr/include/c++/4.8/bits/unordered_map.h:142:35:   required from ‘std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::vector<int>; _Tp = Cell; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]’
cluster.cc:3:18:   required from here
/usr/include/c++/4.8/bits/hashtable_policy.h:1099:63: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }
                                                               ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1099:63: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }
                                                               ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h: In instantiation of ‘std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, true>::_Hash_code_base(const _ExtractKey&, const _H1&, const _H2&, const std::__detail::_Default_ranged_hash&) [with _Key = std::vector<int>; _Value = std::vector<int>; _ExtractKey = std::__detail::_Identity; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing]’:
/usr/include/c++/4.8/bits/hashtable_policy.h:1463:65:   required from ‘std::__detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>::_Hashtable_base(const _ExtractKey&, const _H1&, const _H2&, const _Hash&, const _Equal&) [with _Key = std::vector<int>; _Value = std::vector<int>; _ExtractKey = std::__detail::_Identity; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _Traits = std::__detail::_Hashtable_traits<true, true, true>]’
/usr/include/c++/4.8/bits/hashtable.h:828:24:   required from ‘std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable(std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type, const _H1&, const _H2&, const _Hash&, const _Equal&, const _ExtractKey&, const allocator_type&) [with _Key = std::vector<int>; _Value = std::vector<int>; _Alloc = std::allocator<std::vector<int> >; _ExtractKey = std::__detail::_Identity; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _RehashPolicy = std::__detail::_Prime_rehash_policy; _Traits = std::__detail::_Hashtable_traits<true, true, true>; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type = long unsigned int; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::allocator_type = std::allocator<std::vector<int> >]’
/usr/include/c++/4.8/bits/hashtable.h:397:26:   required from ‘std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable(std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type, const _H1&, const key_equal&, const allocator_type&) [with _Key = std::vector<int>; _Value = std::vector<int>; _Alloc = std::allocator<std::vector<int> >; _ExtractKey = std::__detail::_Identity; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _RehashPolicy = std::__detail::_Prime_rehash_policy; _Traits = std::__detail::_Hashtable_traits<true, true, true>; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type = long unsigned int; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::key_equal = std::equal_to<std::vector<int> >; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::allocator_type = std::allocator<std::vector<int> >]’
/usr/include/c++/4.8/bits/unordered_set.h:136:35:   required from ‘std::unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(std::unordered_set<_Value, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Value = std::vector<int>; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::vector<int> >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::hasher = std::hash<std::vector<int> >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::vector<int> >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::vector<int> >]’
cluster.cc:3:18:   required from here
/usr/include/c++/4.8/bits/hashtable_policy.h:1099:63: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }
                                                               ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1099:63: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }
                                                               ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from cluster.h:4,
                 from cluster.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h: In instantiation of ‘struct std::__detail::_Hash_code_base<std::vector<int>, std::pair<const std::vector<int>, Cell>, std::__detail::_Select1st, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>’:
/usr/include/c++/4.8/bits/hashtable_policy.h:1402:10:   required from ‘struct std::__detail::_Hashtable_base<std::vector<int>, std::pair<const std::vector<int>, Cell>, std::__detail::_Select1st, std::equal_to<std::vector<int> >, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >’
/usr/include/c++/4.8/bits/hashtable.h:174:11:   required from ‘class std::_Hashtable<std::vector<int>, std::pair<const std::vector<int>, Cell>, std::allocator<std::pair<const std::vector<int>, Cell> >, std::__detail::_Select1st, std::equal_to<std::vector<int> >, std::hash<std::vector<int> >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >’
/usr/include/c++/4.8/bits/unordered_map.h:100:18:   required from ‘class std::unordered_map<std::vector<int>, Cell>’
grid.h:66:38:   required from here
/usr/include/c++/4.8/bits/hashtable_policy.h:1070:12: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1070:12: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1082:53: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1082:53: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
grid.cc: In constructor ‘std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::vector<int>; _Tp = Cell; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]’:
grid.cc:15:12: error: invalid use of incomplete type ‘std::unordered_map<std::vector<int>, Cell>::hasher {aka struct std::hash<std::vector<int> >}’
 GRID::GRID(){
            ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘std::unordered_map<std::vector<int>, Cell>::hasher {aka struct std::hash<std::vector<int> >}’
     struct hash;
            ^
grid.cc:15:12: note:   when instantiating default argument for call to std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::vector<int>; _Tp = Cell; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]
 GRID::GRID(){
            ^
grid.cc:21:46: error: invalid use of incomplete type ‘std::unordered_map<std::vector<int>, Cell>::hasher {aka struct std::hash<std::vector<int> >}’
 GRID::GRID(const string& name):filename_(name){
                                              ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘std::unordered_map<std::vector<int>, Cell>::hasher {aka struct std::hash<std::vector<int> >}’
     struct hash;
            ^
grid.cc:21:46: note:   when instantiating default argument for call to std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::vector<int>; _Tp = Cell; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]
 GRID::GRID(const string& name):filename_(name){
                                              ^
grid.cc: At global scope:
grid.cc:61:24: error: prototype for ‘std::map<std::vector<int>, Cell> GRID::get_gridinfo()’ does not match any in class ‘GRID’
 map<vector<int>, Cell> GRID::get_gridinfo(){
                        ^
In file included from grid.cc:1:0:
grid.h:57:38: error: candidate is: std::unordered_map<std::vector<int>, Cell> GRID::get_gridinfo()
     unordered_map<vector<int>, Cell> get_gridinfo();
                                      ^
grid.cc: In member function ‘void GRID::remove_record_from_grid()’:
grid.cc:104:14: error: ‘struct std::pair<const std::vector<int>, Cell>’ has no member named ‘empty’
     if(iter->empty())
              ^
grid.cc:107:41: error: no matching function for call to ‘std::vector<Pulse>::erase(Pulse&)’
       (iter->second).points.erase(record);
                                         ^
grid.cc:107:41: note: candidates are:
In file included from /usr/include/c++/4.8/vector:69:0,
                 from grid.h:4,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/vector.tcc:134:5: note: std::vector<_Tp, _Alloc>::iterator std::vector<_Tp, _Alloc>::erase(std::vector<_Tp, _Alloc>::iterator) [with _Tp = Pulse; _Alloc = std::allocator<Pulse>; std::vector<_Tp, _Alloc>::iterator = __gnu_cxx::__normal_iterator<Pulse*, std::vector<Pulse> >; typename std::_Vector_base<_Tp, _Alloc>::pointer = Pulse*]
     vector<_Tp, _Alloc>::
     ^
/usr/include/c++/4.8/bits/vector.tcc:134:5: note:   no known conversion for argument 1 from ‘Pulse’ to ‘std::vector<Pulse>::iterator {aka __gnu_cxx::__normal_iterator<Pulse*, std::vector<Pulse> >}’
/usr/include/c++/4.8/bits/vector.tcc:146:5: note: std::vector<_Tp, _Alloc>::iterator std::vector<_Tp, _Alloc>::erase(std::vector<_Tp, _Alloc>::iterator, std::vector<_Tp, _Alloc>::iterator) [with _Tp = Pulse; _Alloc = std::allocator<Pulse>; std::vector<_Tp, _Alloc>::iterator = __gnu_cxx::__normal_iterator<Pulse*, std::vector<Pulse> >; typename std::_Vector_base<_Tp, _Alloc>::pointer = Pulse*]
     vector<_Tp, _Alloc>::
     ^
/usr/include/c++/4.8/bits/vector.tcc:146:5: note:   candidate expects 2 arguments, 1 provided
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h: In instantiation of ‘std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, true>::__hash_code std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, true>::_M_hash_code(const _Key&) const [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _ExtractKey = std::__detail::_Select1st; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, true>::__hash_code = long unsigned int]’:
/usr/include/c++/4.8/bits/hashtable.h:1023:50:   required from ‘std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::iterator std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::find(const key_type&) [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; _ExtractKey = std::__detail::_Select1st; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _RehashPolicy = std::__detail::_Prime_rehash_policy; _Traits = std::__detail::_Hashtable_traits<true, false, true>; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::iterator = std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::key_type = std::vector<int>]’
/usr/include/c++/4.8/bits/unordered_map.h:543:29:   required from ‘std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::find(const key_type&) [with _Key = std::vector<int>; _Tp = Cell; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::pair<const std::vector<int>, Cell>, false, true>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type = std::vector<int>]’
grid.cc:75:31:   required from here
/usr/include/c++/4.8/bits/hashtable_policy.h:1103:22: error: no match for call to ‘(const std::hash<std::vector<int> >) (const std::vector<int>&)’
       { return _M_h1()(__k); }
                      ^
/usr/include/c++/4.8/bits/hashtable_policy.h: In instantiation of ‘std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, true>::_Hash_code_base(const _ExtractKey&, const _H1&, const _H2&, const std::__detail::_Default_ranged_hash&) [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _ExtractKey = std::__detail::_Select1st; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing]’:
/usr/include/c++/4.8/bits/hashtable_policy.h:1463:65:   required from ‘std::__detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>::_Hashtable_base(const _ExtractKey&, const _H1&, const _H2&, const _Hash&, const _Equal&) [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _ExtractKey = std::__detail::_Select1st; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _Traits = std::__detail::_Hashtable_traits<true, false, true>]’
/usr/include/c++/4.8/bits/hashtable.h:828:24:   required from ‘std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable(std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type, const _H1&, const _H2&, const _Hash&, const _Equal&, const _ExtractKey&, const allocator_type&) [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; _ExtractKey = std::__detail::_Select1st; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _RehashPolicy = std::__detail::_Prime_rehash_policy; _Traits = std::__detail::_Hashtable_traits<true, false, true>; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type = long unsigned int; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]’
/usr/include/c++/4.8/bits/hashtable.h:397:26:   required from ‘std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable(std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type, const _H1&, const key_equal&, const allocator_type&) [with _Key = std::vector<int>; _Value = std::pair<const std::vector<int>, Cell>; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; _ExtractKey = std::__detail::_Select1st; _Equal = std::equal_to<std::vector<int> >; _H1 = std::hash<std::vector<int> >; _H2 = std::__detail::_Mod_range_hashing; _Hash = std::__detail::_Default_ranged_hash; _RehashPolicy = std::__detail::_Prime_rehash_policy; _Traits = std::__detail::_Hashtable_traits<true, false, true>; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::size_type = long unsigned int; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::key_equal = std::equal_to<std::vector<int> >; std::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]’
/usr/include/c++/4.8/bits/unordered_map.h:142:35:   required from ‘std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::vector<int>; _Tp = Cell; _Hash = std::hash<std::vector<int> >; _Pred = std::equal_to<std::vector<int> >; _Alloc = std::allocator<std::pair<const std::vector<int>, Cell> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::vector<int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::vector<int>, Cell> >]’
grid.cc:15:12:   required from here
/usr/include/c++/4.8/bits/hashtable_policy.h:1099:63: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }
                                                               ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
In file included from /usr/include/c++/4.8/bits/hashtable.h:35:0,
                 from /usr/include/c++/4.8/unordered_map:47,
                 from grid.h:9,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/hashtable_policy.h:1099:63: error: invalid use of incomplete type ‘struct std::hash<std::vector<int> >’
       : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }
                                                               ^
In file included from /usr/include/c++/4.8/bits/stl_bvector.h:1134:0,
                 from /usr/include/c++/4.8/vector:65,
                 from grid.h:4,
                 from grid.cc:1:
/usr/include/c++/4.8/bits/functional_hash.h:58:12: error: declaration of ‘struct std::hash<std::vector<int> >’
     struct hash;
            ^
